<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloth Engine - Pro Studio v38.0</title>
    <!-- Core Engine Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #a5a5a5; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }
        .no-select { user-select: none; -webkit-user-select: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef, useState, useMemo, useCallback } = React;
        const { 
            Sun, Cloud, ChevronDown, ChevronUp, Palette, Box, Sparkles, Camera, Wind,
            Tv, Download, FolderOpen, LayoutGrid, Circle, ZoomIn, Lightbulb, SunMedium,
            Hand, Dices, RefreshCw, Zap, Target, Flame, Waves, Skull,
            ArrowRightLeft, ArrowUpDown, Layers
        } = lucide;

        // --- SHADER SOURCE ---
        const vertexShader = `
            attribute vec3 aBarycentric;
            varying vec3 vBarycentric, vNormal, vWorldNormal, vWorldPosition;
            varying vec2 vUv;
            uniform float uTime, uWindSpeed, uAmplitude, uFrequency, uLayerOffset, uChaos, uPointSize;

            float vHash(vec3 p) {
                p = fract(p * 0.1031);
                p += dot(p, p.yzx + 33.33);
                return fract((p.x + p.y) * p.z);
            }

            void main() {
                vUv = uv; vBarycentric = aBarycentric;
                vec3 pos = position;
                float t = uTime * uWindSpeed + uLayerOffset;
                float wave = sin(pos.x * uFrequency * 0.5 + t) * cos(pos.y * uFrequency * 0.3 + t);
                pos.z += (wave + sin((pos.x + pos.y) * uFrequency + t * 1.5) * 0.15) * uAmplitude;
                if(uChaos > 0.0) pos += (vHash(pos + uTime) - 0.5) * uChaos * 2.5;
                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vWorldPosition = worldPosition.xyz;
                vNormal = normalize(normalMatrix * normal); 
                vWorldNormal = normalize(mat3(modelMatrix) * normal);
                gl_PointSize = uPointSize;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `;

        const fragmentShader = `
            varying vec3 vBarycentric, vNormal, vWorldNormal, vWorldPosition;
            varying vec2 vUv;
            uniform float uTime, uLineWidth, uOpacity, uEnvBrightness, uEnvContrast;
            uniform int uRenderMode, uWireMode;
            uniform vec3 uColor, uColor2, uWireColor, uEmissionColor, uOutlineColor, uLightPos, uCursorLightPos;
            uniform float uEmissionIntensity, uChaos, uCursorLightIntensity, uFireSpeed, uFireScale, uFireIntensity, uTurbSpeed, uTurbScale;
            uniform bool uOutlineEnable, uOutlineEmissive;
            uniform samplerCube uEnvMap;

            float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
            float fbm(vec2 p) {
                float v = 0.0; float a = 0.5;
                for (int i = 0; i < 3; ++i) { 
                    vec2 i_f = floor(p); vec2 fr = fract(p);
                    vec2 u = fr*fr*(3.0-2.0*fr);
                    float n = mix(mix(hash(i_f + vec2(0,0)), hash(i_f + vec2(1,0)), u.x),
                               mix(hash(i_f + vec2(0,1)), hash(i_f + vec2(1,1)), u.x), u.y);
                    v += a * n; p *= 2.0; a *= 0.5; 
                }
                return v;
            }

            void main() {
                vec2 uv = vUv;
                if (uRenderMode == 12) { // Pixelation
                    float pScale = mix(10.0, 200.0, uLineWidth / 5.0);
                    uv = floor(uv * pScale) / pScale;
                }
                vec3 N = normalize(vNormal);
                vec3 V = normalize(cameraPosition - vWorldPosition);
                vec3 R = reflect(-V, normalize(vWorldNormal));
                vec3 env = (textureCube(uEnvMap, R).rgb * uEnvBrightness - 0.5) * uEnvContrast + 0.5;
                vec3 baseCol = uColor;
                if (uRenderMode == 10) { 
                    vec2 fireUv = uv * uFireScale; fireUv.y -= uTime * uFireSpeed;
                    baseCol = mix(uColor, uColor2, fbm(fireUv) * pow(1.0 - uv.y, 2.0) * uFireIntensity);
                } else if (uRenderMode == 13) { 
                    baseCol = mix(uColor, uColor2, fbm(uv * uTurbScale + uTime * uTurbSpeed));
                }
                if (uChaos > 0.0) baseCol += (hash(uv + uTime) - 0.5) * uChaos;
                float diff = max(dot(N, normalize(uLightPos - vWorldPosition)), 0.0);
                vec3 curL = normalize(uCursorLightPos - vWorldPosition);
                float curAtten = 1.0 / (1.0 + distance(uCursorLightPos, vWorldPosition) * 0.1);
                vec3 finalColor = baseCol * (0.3 + diff + max(dot(N, curL), 0.0) * uCursorLightIntensity * curAtten);
                if (uRenderMode == 7) finalColor = mix(finalColor * 0.1, env, 0.95);
                else if (uRenderMode == 1) {
                    float edge;
                    if (uWireMode == 1) edge = vBarycentric.x; else if (uWireMode == 2) edge = vBarycentric.y; else if (uWireMode == 3) edge = vBarycentric.z;
                    else edge = min(min(vBarycentric.x, vBarycentric.y), vBarycentric.z);
                    finalColor = mix(finalColor, uWireColor, 1.0 - smoothstep(0.0, uLineWidth * 0.05, edge));
                } else if (uRenderMode == 14) {
                    float scanline = sin(vWorldPosition.y * 10.0 + uTime * 5.0) * 0.5 + 0.5;
                    finalColor = mix(baseCol, vec3(0.0, 1.0, 1.0), scanline * 0.5) + env * 0.5;
                }
                finalColor += uEmissionColor * uEmissionIntensity;
                if (uOutlineEnable) {
                    float dotNV = max(dot(N, V), 0.0);
                    float sil = 1.0 - smoothstep(0.1, 0.15, dotNV);
                    vec3 strokeCol = uOutlineColor;
                    if (uOutlineEmissive) strokeCol += uEmissionColor * uEmissionIntensity;
                    finalColor = mix(finalColor, strokeCol, sil);
                }
                gl_FragColor = vec4(finalColor, uOpacity);
            }
        `;

        // --- SUB-COMPONENTS ---
        const ControlGroup = ({ title, icon: Icon, children, collapsed, onToggle }) => (
            <div className="mb-4 overflow-hidden rounded-xl border border-white/20 bg-black shadow-2xl">
                <button onClick={onToggle} className="flex w-full items-center justify-between p-3 transition-colors hover:bg-zinc-900">
                    <div className="flex items-center gap-2 font-bold text-white text-xs tracking-wider uppercase">
                        {Icon && <Icon size={14} className="text-blue-500 shrink-0" />}
                        <span className="truncate">{title}</span>
                    </div>
                    {collapsed ? <ChevronDown size={14} className="text-zinc-500" /> : <ChevronUp size={14} className="text-zinc-500" />}
                </button>
                {!collapsed && <div className="p-3 pt-0 space-y-4 border-t border-white/5">{children}</div>}
            </div>
        );

        const Slider = ({ label, value, min, max, step = 0.1, onChange }) => (
            <div className="space-y-1.5">
                <div className="flex justify-between text-[10px] font-bold uppercase tracking-widest text-zinc-400">
                    <span>{label}</span>
                    <span className="font-mono text-blue-400">{typeof value === 'number' ? value.toFixed(2) : value}</span>
                </div>
                <input type="range" min={min} max={max} step={step} value={value} onChange={(e) => onChange(parseFloat(e.target.value))} className="w-full h-1 bg-zinc-800 rounded-lg appearance-none cursor-pointer accent-blue-500"/>
            </div>
        );

        const Select = ({ label, options, value, onChange }) => (
            <div className="space-y-1.5">
                <span className="text-[10px] font-bold uppercase tracking-widest text-zinc-400">{label}</span>
                <select value={value} onChange={(e) => onChange(e.target.value)} className="w-full bg-zinc-900 border border-white/10 rounded-lg p-2 text-[11px] font-bold text-white outline-none cursor-pointer">
                    {options.map(o => <option key={o} value={o}>{o}</option>)}
                </select>
            </div>
        );

        // --- ENGINE CONSTANTS ---
        const INITIAL_LAYERS = 9;
        const createDefaultLayer = (id) => ({
            id, enabled: true, style: "Chrome", wireMode: "All", shape: "Square", poly: 40,
            color: id % 2 === 0 ? "#ffffff" : "#6366f1", color2: "#ff0000", wireColor: "#000000",
            opacity: 1.0, lineWidth: 1.0, pointSize: 10, chaos: 0.0,
            lx: 15, ly: 25, lz: 15, wind: 1.2, amp: 1.0, freq: 1.0, 
            emission: 0.0, emissionColor: "#ffffff",
            fireSpeed: 1.5, fireScale: 2.0, fireIntensity: 1.5, turbSpeed: 2.0, turbScale: 10.0,
            outline: false, outlineColor: "#000000", outlineEmissive: false, envB: 1.0, envC: 1.0,
            rotX: 0, rotY: 0, rotZ: 0
        });

        // --- MAIN APP ---
        function App() {
            const containerRef = useRef(null);
            const cameraStateRef = useRef({ rotation: { x: 0, y: 0 }, offset: { x: 0, y: 0 }, cursorWorld: new THREE.Vector3() });
            const engineRef = useRef({ renderer: null, scene: null, camera: null, layers: [], clock: new THREE.Clock(), active: false, pivot: null, mountId: 0 });

            const [global, setGlobal] = useState({ bgColor: "#a5a5a5", spacing: 13.0, zoom: 1.0, distribution: "Planar Grid", cursorLight: 2.0 });
            const [layers, setLayers] = useState(() => Array.from({ length: 9 }, (_, i) => createDefaultLayer(i + 1)));
            const [activeLayer, setActiveLayer] = useState(0);
            const [collapsed, setCollapsed] = useState({ global: false, style: false, physics: true });

            const updateLayer = (index, key, val) => { setLayers(prev => { const n = [...prev]; n[index] = { ...n[index], [key]: val }; return n; }); };
            const randomizeItem = (idx) => {
                const modes = ["Solid", "Wireframe", "Points", "Glass", "Reflective", "X-Ray", "Polygon", "Chrome", "Shiny Plastic", "Toon", "Fire", "Rain", "Pixelation", "Turbulence", "Hologram"];
                const hex = () => "#" + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                setLayers(prev => {
                    const n = [...prev]; n[idx] = { ...n[idx], style: modes[Math.floor(Math.random()*modes.length)], color: hex(), color2: hex(), emission: Math.random()*5, chaos: Math.random() };
                    return n;
                });
            };
            const focusItem = () => {
                const i = activeLayer, s = global.spacing;
                let tx = 0, ty = 0;
                if (global.distribution === "Planar Grid") { tx = -( (i % 3) * s - s ); ty = -( Math.floor(i/3) * s - s ); }
                else if (global.distribution === "X-Stack") tx = -(i * s - (4 * s));
                else if (global.distribution === "Y-Stack") ty = -(i * s - (4 * s));
                setGlobal(prev => ({ ...prev, zoom: 3.5 }));
                cameraStateRef.current.offset = { x: tx, y: ty };
            };

            useEffect(() => {
                if (!containerRef.current) return;
                const mId = ++engineRef.current.mountId;
                const ctx = engineRef.current; ctx.active = true;
                const scene = new THREE.Scene(), pivot = new THREE.Group(); scene.add(pivot); ctx.pivot = pivot;
                const aspect = window.innerWidth / window.innerHeight;
                const camera = new THREE.OrthographicCamera(-20 * aspect, 20 * aspect, 20, -20, 1, 4000);
                camera.position.set(0, 0, 100); ctx.camera = camera;
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                containerRef.current.appendChild(renderer.domElement);
                ctx.renderer = renderer; ctx.layers = [];

                layers.forEach((l, i) => {
                    if (!l.enabled) { ctx.layers.push(null); return; }
                    const geo = new THREE.PlaneGeometry(12, 12, Math.floor(l.poly), Math.floor(l.poly)).toNonIndexed();
                    const bary = new Float32Array(geo.attributes.position.count * 3);
                    geo.setAttribute('aBarycentric', new THREE.BufferAttribute(bary, 3));
                    const mat = new THREE.ShaderMaterial({
                        uniforms: {
                            uTime: { value: 0 }, uWindSpeed: { value: l.wind }, uAmplitude: { value: l.amp }, uFrequency: { value: l.freq },
                            uColor: { value: new THREE.Color(l.color) }, uColor2: { value: new THREE.Color(l.color2) },
                            uWireColor: { value: new THREE.Color(l.wireColor) }, uLineWidth: { value: l.lineWidth }, uOpacity: { value: l.opacity },
                            uEmissionColor: { value: new THREE.Color(l.emissionColor) }, uEmissionIntensity: { value: l.emission },
                            uChaos: { value: l.chaos }, uPointSize: { value: l.pointSize }, uLightPos: { value: new THREE.Vector3(15, 25, 15) },
                            uCursorLightPos: { value: new THREE.Vector3() }, uCursorLightIntensity: { value: global.cursorLight },
                            uEnvBrightness: { value: 1.0 }, uEnvContrast: { value: 1.0 }, uRenderMode: { value: 0 }, uWireMode: { value: 0 },
                            uFireSpeed: { value: l.fireSpeed }, uFireScale: { value: l.fireScale }, uFireIntensity: { value: l.fireIntensity },
                            uTurbSpeed: { value: l.turbSpeed }, uTurbScale: { value: l.turbScale }, uOutlineEnable: { value: l.outline },
                            uOutlineColor: { value: new THREE.Color(l.outlineColor) }, uOutlineEmissive: { value: l.outlineEmissive }, uEnvMap: { value: new THREE.CubeTexture() }, uLayerOffset: { value: i * 2.0 }
                        },
                        vertexShader, fragmentShader, transparent: true, side: THREE.DoubleSide
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    const s = global.spacing;
                    if (global.distribution === "Planar Grid") mesh.position.set((i % 3) * s - s, Math.floor(i / 3) * s - s, 0);
                    else if (global.distribution === "X-Stack") mesh.position.set(i * s - (4 * s), 0, 0);
                    else if (global.distribution === "Y-Stack") mesh.position.set(0, i * s - (4 * s), 0);
                    else mesh.position.set(0, 0, i * s - (4 * s));
                    pivot.add(mesh); ctx.layers.push(mesh);
                });

                let frameId;
                const animate = () => {
                    if (!ctx.active || mId !== engineRef.current.mountId) return;
                    const t = ctx.clock.getElapsedTime();
                    camera.zoom = global.zoom; camera.updateProjectionMatrix();
                    pivot.position.set(cameraStateRef.current.offset.x, cameraStateRef.current.offset.y, 0);
                    ctx.layers.forEach((m, idx) => {
                        if (m && m.material.uniforms) {
                            const l = layers[idx];
                            const modeMap = { "Solid": 0, "Wireframe": 1, "Points": 2, "Glass": 3, "Reflective": 4, "X-Ray": 5, "Polygon": 6, "Chrome": 7, "Shiny Plastic": 8, "Toon": 9, "Fire": 10, "Rain": 11, "Pixelation": 12, "Turbulence": 13, "Hologram": 14 };
                            m.material.uniforms.uTime.value = t; m.material.uniforms.uRenderMode.value = modeMap[l.style] || 0;
                            m.rotation.x += l.rotX * 0.01; m.rotation.y += l.rotY * 0.01; m.rotation.z += l.rotZ * 0.01;
                        }
                    });
                    renderer.render(scene, camera); frameId = requestAnimationFrame(animate);
                }; animate();

                let isDragging = false, lastPos = { x: 0, y: 0 };
                const onDown = (e) => { isDragging = true; lastPos = { x: e.clientX, y: e.clientY }; }
                const onMove = (e) => { 
                    if(!isDragging) return;
                    pivot.rotation.y += (e.clientX - lastPos.x) * 0.01; pivot.rotation.x += (e.clientY - lastPos.y) * 0.01;
                    lastPos = { x: e.clientX, y: e.clientY };
                }
                const onUp = () => isDragging = false;
                window.addEventListener('mousedown', onDown); window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
                window.addEventListener('resize', () => { renderer.setSize(window.innerWidth, window.innerHeight); camera.left = -20 * (window.innerWidth/window.innerHeight); camera.right = 20 * (window.innerWidth/window.innerHeight); camera.updateProjectionMatrix(); });

                return () => { ctx.active = false; cancelAnimationFrame(frameId); if (renderer.domElement) containerRef.current.removeChild(renderer.domElement); renderer.dispose(); };
            }, [layers, global.distribution, global.spacing, global.zoom]);

            return (
                <div className="relative h-screen w-full overflow-hidden no-select" style={{backgroundColor: global.bgColor}}>
                    <div ref={containerRef} className="w-full h-full cursor-grab active:cursor-grabbing" />
                    <div className="absolute left-6 top-6 bottom-6 w-80 z-50 pointer-events-none text-white font-sans">
                        <div className="h-full w-full pointer-events-auto overflow-y-auto pr-2 custom-scrollbar bg-black/90 rounded-2xl p-4 border border-white/10 shadow-2xl">
                            <div className="flex items-center gap-3 mb-6 px-1">
                                <div className="p-2 bg-blue-600 rounded-lg"><Sparkles size={20} /></div>
                                <h1 className="text-sm font-black uppercase tracking-widest leading-none">Cloth Studio</h1>
                            </div>
                            <div className="grid grid-cols-2 gap-2 mb-4 px-1">
                                <button onClick={() => setLayers(layers.map((l, i) => ({...l, style: "Solid"})))} className="py-2.5 bg-blue-600 rounded-lg text-[10px] font-bold uppercase flex items-center justify-center gap-2 hover:bg-blue-500 active:scale-95 transition-all"><Dices size={14}/> Chaos All</button>
                                <button onClick={() => setLayers(layers.map((_, i) => createDefaultLayer(i+1)))} className="py-2.5 bg-red-600/20 border border-red-500/30 text-red-400 rounded-lg text-[10px] font-bold uppercase active:scale-95 transition-all"><RefreshCw size={14}/> Reset All</button>
                            </div>
                            <ControlGroup title="Global" icon={Sun} collapsed={collapsed.global} onToggle={() => setCollapsed({...collapsed, global: !collapsed.global})}>
                                <Slider label="Zoom" value={global.zoom} min={0.1} max={5} onChange={v => setGlobal({...global, zoom: v})} />
                                <Slider label="Spacing" value={global.spacing} min={5} max={30} onChange={v => setGlobal({...global, spacing: v})} />
                                <div className="grid grid-cols-4 gap-1 mt-2">
                                    {[ {id: "Z-Stack", icon: Layers}, {id: "Planar Grid", icon: LayoutGrid}, {id: "X-Stack", icon: ArrowRightLeft}, {id: "Y-Stack", icon: ArrowUpDown} ].map(m => {
                                        const IconComp = m.icon;
                                        return (
                                            <button key={m.id} onClick={() => setGlobal({...global, distribution: m.id})} className={`p-2 rounded border flex justify-center transition-all ${global.distribution === m.id ? 'bg-blue-600 border-blue-400' : 'bg-zinc-800 opacity-50'}`}>
                                                <IconComp size={14} className="text-white" />
                                            </button>
                                        );
                                    })}
                                </div>
                            </ControlGroup>
                            <div className="grid grid-cols-3 gap-1 my-6 bg-zinc-900 p-1 rounded-xl">
                                {layers.map((_, i) => (
                                    <button key={i} onClick={() => setActiveLayer(i)} className={`py-2 text-[10px] font-black rounded-lg transition-all ${activeLayer === i ? 'bg-blue-600' : 'text-zinc-500 hover:text-white'}`}>{i + 1}</button>
                                ))}
                            </div>
                            <div className="space-y-4">
                                <div className="flex items-center justify-between px-1 mb-2">
                                    <h3 className="text-[10px] font-black uppercase text-blue-400 flex items-center gap-2 tracking-widest"><Box size={14}/> Item {activeLayer + 1}</h3>
                                    <div className="flex gap-1">
                                        <button onClick={focusItem} title="Focus" className="p-1.5 bg-zinc-800 rounded-lg hover:text-blue-400 border border-white/5 transition-all"><Target size={14}/></button>
                                        <button onClick={() => randomizeItem(activeLayer)} title="Random" className="p-1.5 bg-zinc-800 rounded-lg hover:text-blue-400 border border-white/5 active:scale-90 transition-all"><Dices size={14}/></button>
                                        <button onClick={() => updateLayer(activeLayer, 'enabled', !layers[activeLayer].enabled)} className={`px-3 py-1 rounded-full text-[9px] font-black transition-all ${layers[activeLayer].enabled ? 'bg-blue-600' : 'bg-zinc-800 text-zinc-500'}`}>{layers[activeLayer].enabled ? 'ON' : 'OFF'}</button>
                                    </div>
                                </div>
                                <ControlGroup title="Material" icon={Palette} collapsed={collapsed.style} onToggle={() => setCollapsed({...collapsed, style: !collapsed.style})}>
                                    <Select label="Mode" options={["Solid", "Wireframe", "Points", "Glass", "Reflective", "X-Ray", "Polygon", "Chrome", "Shiny Plastic", "Toon", "Fire", "Rain", "Pixelation", "Turbulence", "Hologram"]} value={layers[activeLayer].style} onChange={v => updateLayer(activeLayer, 'style', v)} />
                                    <Slider label="Emission" value={layers[activeLayer].emission} min={0} max={10} onChange={v => updateLayer(activeLayer, 'emission', v)} />
                                    <Slider label="Chaos" value={layers[activeLayer].chaos} min={0} max={3} onChange={v => updateLayer(activeLayer, 'chaos', v)} />
                                    <div className="grid grid-cols-2 gap-2 pt-2">
                                        <input type="color" value={layers[activeLayer].color} onChange={e => updateLayer(activeLayer, 'color', e.target.value)} className="w-full h-8 rounded-lg bg-zinc-900 border-none cursor-pointer" title="Base Color" />
                                        <input type="color" value={layers[activeLayer].color2} onChange={e => updateLayer(activeLayer, 'color2', e.target.value)} className="w-full h-8 rounded-lg bg-zinc-900 border-none cursor-pointer" title="Mix Color" />
                                    </div>
                                </ControlGroup>
                                <ControlGroup title="Physics" icon={Wind} collapsed={collapsed.physics} onToggle={() => setCollapsed({...collapsed, physics: !collapsed.physics})}>
                                    <Slider label="Speed" value={layers[activeLayer].wind} min={0.1} max={5.0} onChange={v => updateLayer(activeLayer, 'wind', v)} />
                                    <Slider label="Height" value={layers[activeLayer].amp} min={0} max={10} onChange={v => updateLayer(activeLayer, 'amp', v)} />
                                    <div className="grid grid-cols-3 gap-1 pt-2">
                                        <Slider label="RotX" value={layers[activeLayer].rotX} min={-5} max={5} onChange={v => updateLayer(activeLayer, 'rotX', v)} />
                                        <Slider label="RotY" value={layers[activeLayer].rotY} min={-5} max={5} onChange={v => updateLayer(activeLayer, 'rotY', v)} />
                                        <Slider label="RotZ" value={layers[activeLayer].rotZ} min={-5} max={5} onChange={v => updateLayer(activeLayer, 'rotZ', v)} />
                                    </div>
                                </ControlGroup>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
        setTimeout(() => lucide.createIcons(), 500);
    </script>
</body>
</html>
