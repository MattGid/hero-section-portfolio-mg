<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloth Engine - Pro Studio v32.1</title>
    <!-- Dependencies -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #a5a5a5; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 10px; }
        canvas { display: block; }
        input[type="range"] { accent-color: #2563eb; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useEffect, useRef, useState, useMemo, useCallback } = React;
        const { 
            Sun, Cloud, ChevronDown, ChevronUp, Palette, Box, Upload, Sparkles, Camera, Wind,
            Tv, Download, FolderOpen, LayoutGrid, Layers, Circle, ZoomIn, Lightbulb, SunMedium,
            Hand, Dices, MousePointer2, RefreshCw, Zap, Target, Flame, Waves, Skull,
            ArrowRightLeft, ArrowUpDown
        } = lucide;

        // --- UI SUB-COMPONENTS ---

        const ControlGroup = ({ title, icon: Icon, children, collapsed, onToggle }) => (
            <div className="mb-4 overflow-hidden rounded-xl border border-white/20 bg-black shadow-2xl">
                <button 
                    onClick={onToggle}
                    className="flex w-full items-center justify-between p-3 transition-colors hover:bg-zinc-900"
                >
                    <div className="flex items-center gap-2 font-bold text-white text-xs tracking-wider uppercase text-left">
                        {Icon && <Icon size={14} className="text-blue-500 shrink-0" />}
                        <span className="truncate">{title}</span>
                    </div>
                    {collapsed ? <ChevronDown size={14} className="text-zinc-500 shrink-0" /> : <ChevronUp size={14} className="text-zinc-500 shrink-0" />}
                </button>
                {!collapsed && <div className="p-3 pt-0 space-y-4 border-t border-white/5">{children}</div>}
            </div>
        );

        const Slider = ({ label, value, min, max, step = 0.1, onChange }) => (
            <div className="space-y-1.5">
                <div className="flex justify-between text-[10px] font-bold uppercase tracking-widest text-zinc-400">
                    <span>{label}</span>
                    <span className="font-mono text-blue-400">{typeof value === 'number' ? value.toFixed(2) : value}</span>
                </div>
                <input 
                    type="range" min={min} max={max} step={step} value={value} 
                    onChange={(e) => onChange(parseFloat(e.target.value))}
                    className="w-full h-1 bg-zinc-800 rounded-lg appearance-none cursor-pointer accent-blue-500"
                />
            </div>
        );

        const Select = ({ label, options, value, onChange }) => (
            <div className="space-y-1.5">
                <span className="text-[10px] font-bold uppercase tracking-widest text-zinc-400">{label}</span>
                <select 
                    value={value} 
                    onChange={(e) => onChange(e.target.value)}
                    className="w-full bg-zinc-900 border border-white/10 rounded-lg p-2 text-[11px] font-bold text-white focus:ring-1 focus:ring-blue-500 outline-none cursor-pointer"
                >
                    {options.map(o => <option key={o} value={o}>{o}</option>)}
                </select>
            </div>
        );

        // --- SHADER SOURCE ---

        const vertexShader = `
            attribute vec3 aBarycentric;
            varying vec3 vBarycentric;
            varying vec2 vUv;
            varying vec3 vNormal;
            varying vec3 vViewPosition;
            varying vec3 vWorldNormal;
            varying vec3 vWorldPosition;
            uniform float uTime, uWindSpeed, uAmplitude, uFrequency, uLayerOffset, uPointSize, uChaos;

            float vHash(vec3 p) {
                p = fract(p * 0.1031);
                p += dot(p, p.yzx + 33.33);
                return fract((p.x + p.y) * p.z);
            }

            void main() {
                vUv = uv;
                vBarycentric = aBarycentric;
                vec3 pos = position;
                float t = uTime * uWindSpeed + uLayerOffset;
                float wave = sin(pos.x * uFrequency * 0.5 + t) * cos(pos.y * uFrequency * 0.3 + t);
                float ripple = sin((pos.x + pos.y) * uFrequency + t * 1.5) * 0.15;
                pos.z += (wave + ripple) * uAmplitude;
                pos.y += sin(uTime * 0.2 + uLayerOffset) * 0.1;
                
                if(uChaos > 0.0) {
                    float j = vHash(pos + uTime);
                    pos += (j - 0.5) * uChaos * 2.5;
                }

                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vWorldPosition = worldPosition.xyz;
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                vViewPosition = -mvPosition.xyz;
                vNormal = normalize(normalMatrix * normal); 
                vWorldNormal = normalize(mat3(modelMatrix) * normal);
                gl_PointSize = uPointSize;
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const fragmentShader = `
            varying vec3 vBarycentric;
            varying vec2 vUv;
            varying vec3 vNormal, vViewPosition, vWorldNormal, vWorldPosition;
            uniform float uTime, uLineWidth, uOpacity, uSpecularIntensity, uSpecularPower, uClearcoat, uAOIntensity;
            uniform float uAmbientIntensity, uDirectionalIntensity, uEnvBlur, uEnvBrightness, uEnvContrast, uEnvScale;
            uniform int uRenderMode, uShape, uWireMode;
            uniform vec3 uColor, uColor2, uWireColor, uEmissionColor, uOutlineColor, uLightPos, uLightColor, uCursorLightPos;
            uniform float uEmissionIntensity, uGlowSpread, uChaos, uCursorLightIntensity, uFireSpeed, uFireScale, uFireIntensity, uTurbSpeed, uTurbScale;
            uniform bool uOutlineEnable, uOutlineEmissive;
            uniform samplerCube uEnvMap;

            float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123); }
            float fbm(vec2 p) {
                float v = 0.0; float a = 0.5;
                for (int i = 0; i < 3; ++i) { 
                    vec2 i_floor = floor(p); vec2 f = fract(p);
                    vec2 u = f*f*(3.0-2.0*f);
                    float n = mix(mix(hash(i_floor + vec2(0,0)), hash(i_floor + vec2(1,0)), u.x),
                               mix(hash(i_floor + vec2(0,1)), hash(i_floor + vec2(1,1)), u.x), u.y);
                    v += a * n; p = p * 2.0 + vec2(10.0); a *= 0.5; 
                }
                return v;
            }
            float getShapeSDF(vec2 uv, int shape) {
                vec2 p = (uv * 2.0 - 1.0) / 0.7; 
                if (shape == 1) return length(p) - 1.0;
                if (shape == 2) { float a = atan(p.x, p.y) + 3.14159; return (cos(floor(0.5 + a/2.09439)*2.09439 - a) * length(p)) - 0.5; }
                if (shape == 3) { vec2 q = abs(p); return max(q.x * 0.866025 + q.y * 0.5, q.y) - 0.9; }
                return max(abs(p.x), abs(p.y)) - 1.0;
            }

            void main() {
                vec2 uv = vUv;
                if (uRenderMode == 12) {
                    float pixelScale = mix(10.0, 200.0, uLineWidth / 5.0);
                    uv = floor(uv * pixelScale) / pixelScale;
                }
                float dist = getShapeSDF(uv, uShape);
                float meshMask = 1.0 - step(0.0, dist);
                float spill = exp(-max(0.0, dist) * (15.0 / max(0.01, uGlowSpread)));
                float spillAlpha = spill * (uEmissionIntensity / 5.0);
                if (meshMask < 0.01 && spillAlpha < 0.01) discard;

                vec3 N = normalize(vNormal);
                vec3 V = normalize(cameraPosition - vWorldPosition);
                vec3 L = normalize(uLightPos - vWorldPosition);
                float dotNV = max(dot(N, V), 0.0);
                float fresnel = pow(1.0 - dotNV, 3.0);
                vec3 finalColor = vec3(0.0);
                float finalAlpha = uOpacity;

                if (meshMask > 0.5) {
                    vec3 baseCol = uColor;
                    if (uRenderMode == 10) {
                        vec2 fUv = uv * uFireScale; fUv.y -= uTime * uFireSpeed;
                        float flame = fbm(fUv) * pow(1.0 - uv.y, 2.0) * uFireIntensity;
                        baseCol = mix(uColor, uColor2, flame);
                        finalAlpha = smoothstep(0.0, 0.5, flame) * uOpacity;
                    } else if (uRenderMode == 13) {
                        baseCol = mix(uColor, uColor2, fbm(uv * uTurbScale + uTime * uTurbSpeed));
                    }
                    if (uChaos > 0.0) baseCol += (hash(uv + uTime) - 0.5) * uChaos;

                    float diff = max(dot(N, L), 0.0);
                    finalColor = baseCol * (uAmbientIntensity + diff * uDirectionalIntensity);
                    
                    vec3 curL = normalize(uCursorLightPos - vWorldPosition);
                    float curAtten = 1.0 / (1.0 + distance(uCursorLightPos, vWorldPosition) * 0.1);
                    finalColor += baseCol * max(dot(N, curL), 0.0) * uCursorLightIntensity * curAtten;

                    if (uRenderMode == 7) {
                        finalColor = mix(finalColor * 0.1, textureCube(uEnvMap, reflect(-V, normalize(vWorldNormal))).rgb, 0.9);
                    } else if (uRenderMode == 1) {
                        float edge;
                        if (uWireMode == 1) edge = vBarycentric.x; else if (uWireMode == 2) edge = vBarycentric.y; else if (uWireMode == 3) edge = vBarycentric.z;
                        else edge = min(min(vBarycentric.x, vBarycentric.y), vBarycentric.z);
                        float wMask = 1.0 - smoothstep(0.0, uLineWidth * 0.05, edge);
                        finalColor = mix(finalColor, uWireColor, wMask);
                        finalAlpha *= mix(0.1, 1.0, wMask);
                    } else if (uRenderMode == 2) {
                         if (length(gl_PointCoord - 0.5) > 0.5) discard;
                         finalColor = uWireColor + uEmissionColor * uEmissionIntensity;
                    }

                    finalColor += uEmissionColor * uEmissionIntensity;
                    if (uOutlineEnable) {
                        float border = 1.0 - smoothstep(-0.02, 0.0, dist);
                        float sil = 1.0 - smoothstep(uOutlineWidth, uOutlineWidth + 0.05, dotNV);
                        vec3 strokeCol = uOutlineColor;
                        if (uOutlineEmissive) strokeCol += uEmissionColor * uEmissionIntensity;
                        finalColor = mix(finalColor, strokeCol, max(sil, border));
                    }
                } else {
                    finalColor = uEmissionColor * uEmissionIntensity;
                    finalAlpha = spillAlpha * uOpacity;
                }
                gl_FragColor = vec4(finalColor, finalAlpha);
            }
        `;

        // --- COMPONENTS ---

        const INITIAL_LAYERS_COUNT = 9;
        const createDefaultLayer = (id, forceOn = false) => ({
            id, enabled: forceOn || id === 1, style: "Chrome", wireMode: "All", shape: "Square", poly: 40,
            color: id % 2 === 0 ? "#ffffff" : "#6366f1", color2: "#ff0000", wireColor: "#000000",
            opacity: 1.0, lineWidth: 1.0, spec: 1.0, specP: 64, pointSize: 10, chaos: 0.0,
            envB: 1.0, envC: 1.0, envS: 1.0, envBlur: 0.0, lx: 15, ly: 25, lz: 15, ao: 0.5, clearcoat: 0.0, 
            ambient: 0.1, direct: 1.0, shadInt: 0.5, shadSoft: 0.1, wind: 1.2, amp: 1.0, freq: 1.0, aberration: 0.0, 
            grain: 0.0, rotX: 0, rotY: 0, rotZ: 0, outline: false, outlineWidth: 0.2, outlineColor: "#000000", 
            outlineEmissive: false, emission: 0.0, emissionColor: "#ffffff", glowSpread: 0.5,
            fireSpeed: 1.5, fireScale: 2.0, fireIntensity: 1.5, turbSpeed: 2.0, turbScale: 10.0
        });

        const DEFAULT_GLOBAL = { rotationSpeed: 0.00, layerSpacing: 13.0, clothSize: 10, customHdriUrl: null, bgColor: "#a5a5a5", distributionMode: "Planar Grid", zoom: 1.0, cursorLight: 2.0 };

        function App() {
            const containerRef = useRef(null);
            const cameraStateRef = useRef({ rotation: { x: 0, y: 0, z: 0 }, zoom: 1.0, offset: { x: 0, y: 0 }, cursorWorld: new THREE.Vector3() });
            const engineRef = useRef({ renderer: null, scene: null, camera: null, layers: [], clock: new THREE.Clock(), active: false, pivot: null, mountId: 0 });

            const [globalConfig, setGlobalConfig] = useState(DEFAULT_GLOBAL);
            const [layers, setLayers] = useState(() => Array.from({ length: 9 }, (_, i) => createDefaultLayer(i + 1)));
            const [activeLayer, setActiveLayer] = useState(0);
            const [collapsed, setCollapsed] = useState({ global: false, style: false, camera: false, physics: true });

            // --- CALLBACKS ---

            const updateLayer = useCallback((index, key, val) => {
                setLayers(prev => { const n = [...prev]; n[index] = { ...n[index], [key]: val }; return n; });
            }, []);

            const snapCamera = useCallback((m) => {
                const p = engineRef.current.pivot; if (!p) return;
                if (m === 'iso') p.rotation.set(Math.atan(1 / Math.sqrt(2)), Math.PI / 4, 0); 
                else if (m === 'top') p.rotation.set(Math.PI / 2, 0, 0); 
                else if (m === 'front') p.rotation.set(0, 0, 0); 
                else if (m === 'side') p.rotation.set(0, Math.PI / 2, 0);
                p.position.set(0,0,0); cameraStateRef.current.offset = { x: 0, y: 0 };
                cameraStateRef.current.rotation = { x: p.rotation.x, y: p.rotation.y, z: p.rotation.z };
            }, []);

            const randomizeItem = useCallback((idx) => {
                const renderModes = ["Solid", "Wireframe", "Points", "Glass", "Reflective", "X-Ray", "Polygon", "Chrome", "Shiny Plastic", "Toon", "Fire", "Rain", "Pixelation", "Turbulence", "Hologram"];
                const shapes = ["Square", "Circle", "Triangle", "Hexagon"];
                const randomHex = () => "#" + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                setLayers(prev => {
                    const n = [...prev]; const cur = n[idx];
                    n[idx] = {
                        ...cur, enabled: true, style: renderModes[Math.floor(Math.random() * renderModes.length)], 
                        shape: shapes[Math.floor(Math.random() * shapes.length)],
                        color: randomHex(), color2: randomHex(), emissionColor: randomHex(), 
                        emission: Math.random() * 8, glowSpread: 0.2 + Math.random() * 1.5,
                        chaos: Math.random() < 0.4 ? Math.random() * 2.0 : 0
                    };
                    return n;
                });
            }, []);

            const randomizeAll = useCallback(() => {
                for(let i=0; i<INITIAL_LAYERS_COUNT; i++) randomizeItem(i);
            }, [randomizeItem]);

            const resetToDefaults = useCallback(() => {
                setGlobalConfig(DEFAULT_GLOBAL);
                setLayers(Array.from({ length: 9 }, (_, i) => createDefaultLayer(i + 1, true)));
            }, []);

            const focusOnActive = useCallback(() => {
                const i = activeLayer, s = globalConfig.layerSpacing, size = globalConfig.clothSize;
                let tx = 0, ty = 0;
                if (globalConfig.distributionMode === "Planar Grid") {
                    const row = Math.floor(i / 3), col = i % 3;
                    tx = -(col * s - s); ty = -(row * s - s);
                } else if (globalConfig.distributionMode === "X-Stack") {
                    tx = -(i * s - (4 * s)); ty = 0;
                } else if (globalConfig.distributionMode === "Y-Stack") {
                    tx = 0; ty = -(i * s - (4 * s));
                }
                const targetZoom = (50 / (size * 1.5)) * 0.8;
                setGlobalConfig(prev => ({ ...prev, zoom: targetZoom }));
                cameraStateRef.current.offset = { x: tx, y: ty };
                if (engineRef.current.pivot) engineRef.current.pivot.position.set(tx, ty, 0);
            }, [activeLayer, globalConfig.layerSpacing, globalConfig.clothSize, globalConfig.distributionMode]);

            const saveConfig = useCallback(() => {
                const data = { globalConfig, layers };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
                const link = document.createElement("a"); link.href = URL.createObjectURL(blob); link.download = `cloth-config.json`; link.click();
            }, [globalConfig, layers]);

            // --- ENGINE SETUP ---

            useEffect(() => {
                if (!containerRef.current) return;
                const currentMountId = ++engineRef.current.mountId;
                const engine = engineRef.current;
                engine.active = true;
                const scene = new THREE.Scene(), pivot = new THREE.Group(); scene.add(pivot); engine.pivot = pivot;
                const aspect = window.innerWidth / window.innerHeight;
                const camera = new THREE.OrthographicCamera(-25 * aspect, 25 * aspect, 25, -25, 1, 4000);
                camera.position.set(0, 0, 100); camera.zoom = globalConfig.zoom; camera.updateProjectionMatrix();
                
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                containerRef.current.appendChild(renderer.domElement);
                engine.renderer = renderer; engine.scene = scene; engine.camera = camera; engine.layers = [];

                pivot.rotation.set(cameraStateRef.current.rotation.x, cameraStateRef.current.rotation.y, 0);
                pivot.position.set(cameraStateRef.current.offset.x, cameraStateRef.current.offset.y, 0);

                layers.forEach((l, i) => {
                    if (!l.enabled) return;
                    const geo = new THREE.PlaneGeometry(globalConfig.clothSize * 1.5, globalConfig.clothSize * 1.5, Math.floor(l.poly), Math.floor(l.poly)).toNonIndexed();
                    const count = geo.attributes.position.count;
                    const bary = new Float32Array(count * 3);
                    for (let j = 0; j < count; j++) { 
                        const m = j % 3; 
                        if (m === 0) { bary[j*3]=1; bary[j*3+1]=0; bary[j*3+2]=0; } 
                        else if (m === 1) { bary[j*3]=0; bary[j*3+1]=1; bary[j*3+2]=0; } 
                        else { bary[j*3]=0; bary[j*3+1]=0; bary[j*3+2]=1; } 
                    }
                    geo.setAttribute('aBarycentric', new THREE.BufferAttribute(bary, 3));
                    const mat = new THREE.ShaderMaterial({
                        uniforms: {
                            uTime: { value: 0 }, uWindSpeed: { value: l.wind }, uAmplitude: { value: l.amp }, uFrequency: { value: l.freq },
                            uColor: { value: new THREE.Color(l.color) }, uColor2: { value: new THREE.Color(l.color2) },
                            uWireColor: { value: new THREE.Color(l.wireColor) }, uLineWidth: { value: l.lineWidth }, uOpacity: { value: l.opacity },
                            uEmissionColor: { value: new THREE.Color(l.emissionColor) }, uEmissionIntensity: { value: l.emission },
                            uGlowSpread: { value: l.glowSpread }, uChaos: { value: l.chaos }, uPointSize: { value: l.pointSize },
                            uLightPos: { value: new THREE.Vector3(l.lx, l.ly, l.lz) }, uCursorLightPos: { value: new THREE.Vector3() }, uCursorLightIntensity: { value: globalConfig.cursorLight },
                            uAmbientIntensity: { value: l.ambient }, uDirectionalIntensity: { value: l.direct }, uEnvScale: { value: l.envS }, uEnvBrightness: { value: l.envB },
                            uEnvContrast: { value: l.envC }, uRenderMode: { value: 0 }, uShape: { value: 0 }, uWireMode: { value: 0 }, uLayerOffset: { value: i * 3.0 },
                            uFireSpeed: { value: l.fireSpeed }, uFireScale: { value: l.fireScale }, uFireIntensity: { value: l.fireIntensity },
                            uTurbSpeed: { value: l.turbSpeed }, uTurbScale: { value: l.turbScale }, uOutlineEnable: { value: l.outline }, uOutlineWidth: { value: l.outlineWidth },
                            uOutlineColor: { value: new THREE.Color(l.outlineColor) }, uOutlineEmissive: { value: l.outlineEmissive }, uEnvMap: { value: new THREE.CubeTexture() }
                        },
                        vertexShader, fragmentShader, transparent: true, side: THREE.DoubleSide, extensions: { derivatives: true }
                    });
                    const mesh = l.style === "Points" ? new THREE.Points(geo, mat) : new THREE.Mesh(geo, mat);
                    const s = globalConfig.layerSpacing;
                    if (globalConfig.distributionMode === "Planar Grid") mesh.position.set((i % 3) * s - s, Math.floor(i / 3) * s - s, 0);
                    else if (globalConfig.distributionMode === "X-Stack") mesh.position.set(i * s - (4 * s), 0, 0);
                    else if (globalConfig.distributionMode === "Y-Stack") mesh.position.set(0, i * s - (4 * s), 0);
                    else mesh.position.set(0, 0, i * s - (4 * s));
                    pivot.add(mesh); engine.layers.push(mesh);
                });

                // Interaction Handling
                let isDragging = false, prevMouse = { x: 0, y: 0 };
                const handleDown = (e) => { isDragging = true; prevMouse = { x: e.clientX, y: e.clientY }; };
                const handleMove = (e) => {
                    if (!isDragging) return;
                    pivot.rotation.y += (e.clientX - prevMouse.x) * 0.01;
                    pivot.rotation.x += (e.clientY - prevMouse.y) * 0.01;
                    prevMouse = { x: e.clientX, y: e.clientY };
                    cameraStateRef.current.rotation = { x: pivot.rotation.x, y: pivot.rotation.y };
                };
                const handleUp = () => { isDragging = false; };
                const cont = containerRef.current;
                cont.addEventListener('mousedown', handleDown); window.addEventListener('mousemove', handleMove); window.addEventListener('mouseup', handleUp);

                let frameId;
                const animate = () => {
                    if (!engine.active) return;
                    const t = engine.clock.getElapsedTime();
                    camera.zoom = globalConfig.zoom; camera.updateProjectionMatrix();
                    engine.layers.forEach((m, idx) => {
                        if(m.material.uniforms) {
                            const l = layers[idx];
                            const modeMap = { "Solid": 0, "Wireframe": 1, "Points": 2, "Glass": 3, "Reflective": 4, "X-Ray": 5, "Polygon": 6, "Chrome": 7, "Shiny Plastic": 8, "Toon": 9, "Fire": 10, "Rain": 11, "Pixelation": 12, "Turbulence": 13, "Hologram": 14 };
                            const shapeMap = { "Square": 0, "Circle": 1, "Triangle": 2, "Hexagon": 3 };
                            const wireModeMap = { "All": 0, "Horizontal": 1, "Vertical": 2, "Diagonal": 3 };
                            m.material.uniforms.uTime.value = t;
                            m.material.uniforms.uRenderMode.value = modeMap[l.style];
                            m.material.uniforms.uShape.value = shapeMap[l.shape];
                            m.material.uniforms.uWireMode.value = wireModeMap[l.wireMode];
                            m.material.uniforms.uCursorLightIntensity.value = globalConfig.cursorLight;
                        }
                    });
                    renderer.render(scene, camera);
                    frameId = requestAnimationFrame(animate);
                };
                animate();

                return () => {
                    engine.active = false; cancelAnimationFrame(frameId);
                    cont.removeEventListener('mousedown', handleDown); window.removeEventListener('mousemove', handleMove); window.removeEventListener('mouseup', handleUp);
                    if (renderer.domElement && cont) cont.removeChild(renderer.domElement);
                    renderer.dispose();
                };
            }, [layers, globalConfig.distributionMode, globalConfig.layerSpacing, globalConfig.zoom, globalConfig.cursorLight, globalConfig.clothSize]);

            return (
                <div className="relative h-screen w-full select-none overflow-hidden" style={{backgroundColor: globalConfig.bgColor}}>
                    <div ref={containerRef} className="w-full h-full cursor-grab active:cursor-grabbing" />
                    
                    <div className="absolute left-6 top-6 bottom-6 w-80 z-50 pointer-events-none">
                        <div className="h-full w-full pointer-events-auto overflow-y-auto bg-black/90 text-white rounded-2xl p-4 border border-white/10 custom-scrollbar shadow-2xl">
                            
                            <div className="flex items-center gap-3 mb-6">
                                <div className="p-2 bg-blue-600 rounded-lg shadow-lg"><Sparkles size={20}/></div>
                                <div>
                                    <h1 className="font-black text-sm uppercase tracking-widest leading-none">Cloth Studio</h1>
                                    <p className="text-[8px] text-zinc-500 uppercase mt-1">Stablestudio v32.0</p>
                                </div>
                            </div>

                            <div className="grid grid-cols-2 gap-2 mb-4">
                                <button onClick={randomizeAll} className="py-2.5 bg-blue-600 rounded-lg text-[10px] font-bold uppercase flex items-center justify-center gap-2 hover:bg-blue-500 transition-all shadow-md active:scale-95">
                                    <Dices size={14}/> Chaos All
                                </button>
                                <button onClick={resetToDefaults} className="py-2.5 bg-red-600/20 border border-red-500/30 text-red-400 rounded-lg text-[10px] font-bold uppercase flex items-center justify-center gap-2 hover:bg-red-600/30 transition-all active:scale-95">
                                    <RefreshCw size={14}/> Reset All
                                </button>
                            </div>

                            <ControlGroup title="Global Settings" icon={Sun} collapsed={collapsed.global} onToggle={() => setCollapsed({...collapsed, global: !collapsed.global})}>
                                <Slider label="Cursor Light" value={globalConfig.cursorLight} min={0} max={10} onChange={v => setGlobalConfig({...globalConfig, cursorLight: v})} />
                                <Slider label="Spacing" value={globalConfig.layerSpacing} min={5} max={30} onChange={v => setGlobalConfig({...globalConfig, layerSpacing: v})} />
                                <div className="grid grid-cols-4 gap-1 mt-2">
                                    {[ {id:"Z-Stack", i:Layers}, {id:"Planar Grid", i:LayoutGrid}, {id:"X-Stack", i:ArrowRightLeft}, {id:"Y-Stack", i:ArrowUpDown} ].map(m => (
                                        <button key={m.id} onClick={() => setGlobalConfig({...globalConfig, distributionMode: m.id})} className={`p-2 rounded border flex justify-center transition-all ${globalConfig.distributionMode === m.id ? 'bg-blue-600 border-blue-400' : 'bg-zinc-800 border-white/5 opacity-50'}`}>
                                            {React.createElement(m.i, { size: 14 })}
                                        </button>
                                    ))}
                                </div>
                            </ControlGroup>

                            <div className="grid grid-cols-3 gap-1 my-6 bg-zinc-900 p-1 rounded-xl shadow-inner">
                                {layers.map((l, i) => (
                                    <button key={i} onClick={() => setActiveLayer(i)} className={`py-2 text-[10px] font-black rounded-lg transition-all ${activeLayer === i ? 'bg-blue-600 shadow-lg scale-105' : 'text-zinc-500 hover:text-white hover:bg-white/5'}`}>
                                        {i+1}
                                    </button>
                                ))}
                            </div>

                            <div className="space-y-4">
                                <div className="flex items-center justify-between">
                                    <h2 className="text-[10px] font-black uppercase text-blue-400 flex items-center gap-2 tracking-widest"><Box size={14}/> Item {activeLayer+1}</h2>
                                    <div className="flex gap-1">
                                        <button onClick={focusOnActive} title="Focus Zoom" className="p-1.5 bg-zinc-800 rounded-lg hover:text-blue-400 border border-white/5 transition-colors"><Target size={14}/></button>
                                        <button onClick={() => randomizeItem(activeLayer)} title="Randomize Aesthetics" className="p-1.5 bg-zinc-800 rounded-lg hover:text-blue-400 border border-white/5 transition-colors"><Dices size={14}/></button>
                                        <button onClick={() => updateLayer(activeLayer, 'enabled', !layers[activeLayer].enabled)} className={`px-3 py-1 rounded-full text-[9px] font-black transition-all ${layers[activeLayer].enabled ? 'bg-blue-600' : 'bg-zinc-800 text-zinc-500'}`}>{layers[activeLayer].enabled ? 'ON' : 'OFF'}</button>
                                    </div>
                                </div>

                                <ControlGroup title="Shader & Style" icon={Palette} collapsed={collapsed.style} onToggle={() => setCollapsed({...collapsed, style: !collapsed.style})}>
                                    <Select label="Render Mode" options={["Solid", "Wireframe", "Points", "Glass", "Reflective", "X-Ray", "Polygon", "Chrome", "Shiny Plastic", "Toon", "Fire", "Rain", "Pixelation", "Turbulence", "Hologram"]} value={layers[activeLayer].style} onChange={v => updateLayer(activeLayer, 'style', v)} />
                                    <Select label="Shape" options={["Square", "Circle", "Triangle", "Hexagon"]} value={layers[activeLayer].shape} onChange={v => updateLayer(activeLayer, 'shape', v)} />
                                    
                                    {layers[activeLayer].style === "Fire" && (
                                        <div className="space-y-3 pt-2 border-t border-white/5">
                                            <Slider label="Flame Speed" value={layers[activeLayer].fireSpeed} min={0.1} max={5.0} onChange={v => updateLayer(activeLayer, 'fireSpeed', v)} />
                                            <Slider label="Heat" value={layers[activeLayer].fireIntensity} min={0.1} max={5.0} onChange={v => updateLayer(activeLayer, 'fireIntensity', v)} />
                                        </div>
                                    )}
                                    
                                    <Slider label="Emission" value={layers[activeLayer].emission} min={0} max={10} onChange={v => updateLayer(activeLayer, 'emission', v)} />
                                    <Slider label="Chaos" value={layers[activeLayer].chaos} min={0} max={5} onChange={v => updateLayer(activeLayer, 'chaos', v)} />
                                    
                                    <div className="grid grid-cols-2 gap-2 pt-2">
                                        <div className="space-y-1"><span className="text-[8px] text-zinc-500 uppercase font-bold">Color 1</span><input type="color" value={layers[activeLayer].color} onChange={e => updateLayer(activeLayer, 'color', e.target.value)} className="w-full h-8 bg-zinc-800 border-none rounded-md cursor-pointer" /></div>
                                        <div className="space-y-1"><span className="text-[8px] text-zinc-500 uppercase font-bold">Color 2</span><input type="color" value={layers[activeLayer].color2} onChange={e => updateLayer(activeLayer, 'color2', e.target.value)} className="w-full h-8 bg-zinc-800 border-none rounded-md cursor-pointer" /></div>
                                    </div>
                                </ControlGroup>

                                <ControlGroup title="Physics & Motion" icon={Wind} collapsed={collapsed.physics} onToggle={() => setCollapsed({...collapsed, physics: !collapsed.physics})}>
                                    <Slider label="Wind Speed" value={layers[activeLayer].wind} min={0.1} max={5.0} onChange={v => updateLayer(activeLayer, 'wind', v)} />
                                    <Slider label="Wave H" value={layers[activeLayer].amp} min={0} max={5} onChange={v => updateLayer(activeLayer, 'amp', v)} />
                                </ControlGroup>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

        // Initialize Lucide Icons after Render
        setTimeout(() => lucide.createIcons(), 500);
    </script>
</body>
</html>
